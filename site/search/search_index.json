{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Buildcpp: A Python Build System for C++ Projects","text":"<p>Buildcpp is a build tool that uses Python as the scripting language for C++ projects. Its minimalist design makes building C++ projects straightforward and efficient.</p>"},{"location":"#installation","title":"Installation","text":"<p>Buildcpp requires Python 3.7 or higher. You can download Python from python.org. Once Python is installed, install Buildcpp via pip:</p> <pre><code>pip install buildcpp\n</code></pre> <p>Buildcpp also depends on CMake 3.15 or later, which you can download from cmake.org. Under the hood, Buildcpp uses Python for front-end scripting and CMake as the back-end build engine.</p>"},{"location":"#usage","title":"Usage","text":"<p>Buildcpp is a Python package that provides a set of APIs for defining and building C++ projects. To use it, simply create a Python script in your project directory and define your build using Buildcpp\u2019s API. Running this script will execute the build.</p> <p>While Buildcpp uses a script-based approach, the script itself resembles a configuration file. This design choice stems from the fact that C++ builds often involve numerous configuration options, which can become cumbersome in static configuration files.</p> <p>Here\u2019s a minimal example:</p> myproject.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\n# Get current directory\nROOT = Path(__file__).parent\n\n# Define a build target\ntarget = Target('main')\\\n    .add_sources(Scope.PRIVATE, ROOT / 'main.cpp')\n\nif __name__ == '__main__':\n    # Create a builder and compile the target\n    builder = Builder()\n    builder.attach(target)\n    builder.build()\n</code></pre> <p>Even without prior Python experience, you can likely understand what\u2019s happening if you\u2019re familiar with C++. The <code>Target</code> object is central to Buildcpp\u2014it holds all the metadata needed for the build, much like a configuration file.</p>"},{"location":"ext/","title":"Extension","text":"<p>Buildcpp is not a closed build system, it provides an extensible interface called <code>AbstractTarget</code>. The <code>Target</code> provided by buildcpp is one of its subclasses. By inheriting <code>AbstractTarget</code> and implementing its abstract methods, you can achieve your own defined target logic.</p> target.py<pre><code>...\n\nclass AbstractTarget(ABC):\n    def __init__(self, name: str) -&gt; None:\n        ...\n\n    @abstractmethod\n    def to_cmake(self) -&gt; str:\n        pass\n\n    def depend_on(self, *targets, allow_invaild=False):\n        ...\n\n    def rename(self, new_name: str):\n        ...\n\n...\n</code></pre> <p>The above is the definition of the abstract class <code>AbstractTarget</code>, which has an abstract method <code>to_cmake</code> used to customize the target logic. Buildcpp is similar to CMake in that it translates Python code into CMake, just like how CMake translates CMake scripts into Makefiles.</p>"},{"location":"quick/","title":"Getting Started","text":"<p>Buildcpp streamlines C++ builds by modeling them as a series of <code>Target</code> constructions. Build order is determined by dependency relationships between targets. Each <code>Target</code> is defined as a set of metadata containing everything needed to produce a single output\u2014such as an executable (<code>.exe</code>), a static library (<code>.lib</code>, <code>.a</code>), or a dynamic library (<code>.dll</code>, <code>.so</code>).</p>"},{"location":"quick/#building-a-single-target","title":"Building a Single <code>Target</code>","text":"<p>Buildcpp scripts are purely declarative. Even with only C++ knowledge and no Python experience, the syntax remains intuitive. Here\u2019s the simplest build script:</p> myproject.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\n# Get the current directory\nROOT = Path(__file__).parent\n# Define a target\ntarget = Target('main')\\\n    .add_sources(Scope.PRIVATE, ROOT / 'main.cpp')\n\nif __name__ == '__main__':\n    # Create a builder and compile the target\n    builder = Builder()\n    builder.attach(target)\n    builder.build()\n</code></pre> <p>The corresponding project structure is:</p> <pre><code>myproject/\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 myproject.py\n</code></pre> <p>Buildcpp does not enforce any specific directory layout\u2014you\u2019re free to organize projects as you prefer.</p> <p>That\u2019s all you need to get started. The <code>Target</code> object also provides additional APIs for configuring metadata like include paths, macro definitions, and more.</p>"},{"location":"quick/#building-multiple-targets","title":"Building Multiple <code>Targets</code>","text":"<p>A Python build script corresponds to a project in buildcpp, and a project can define multiple targets. When a target is built, all of its dependencies are automatically pulled into the build process.</p> <p>To build several executables in one project, simply define multiple targets. For example, with two source files:</p> <pre><code>myproject/\n\u251c\u2500\u2500 main.cpp\n\u251c\u2500\u2500 start.cpp\n\u2514\u2500\u2500 myproject.py\n</code></pre> <p>In <code>myproject.py</code>, define both targets and attach them to the builder:</p> myproject.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\n# Get the current directory\nROOT = Path(__file__).parent\n# Define targets\nmain = Target('main')\\\n    .add_sources(Scope.PRIVATE, ROOT / 'main.cpp')\n\nstart = Target('start')\\\n    .add_sources(Scope.PRIVATE, ROOT / 'start.cpp')\n\nif __name__ == '__main__':\n    # Create a builder and compile the targets\n    builder = Builder()\n    builder.attach(main, start)\n    builder.build()\n</code></pre> <p>This approach is especially useful for compiling multiple test programs or examples in one go.</p>"},{"location":"quick/#building-with-dependencies-combined-target","title":"Building with Dependencies (<code>Combined Target</code>)","text":"<p>Sometimes one target depends on code from another. Consider this project:</p> <pre><code>myproject/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 add.h\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 add.cpp\n\u2502   \u2514\u2500\u2500 main.cpp\n\u2514\u2500\u2500 myproject.py\n</code></pre> <p>If <code>main.cpp</code> uses a function from <code>add.cpp</code>, we could bundle both into one target\u2014but a cleaner approach is to model them as separate targets with a dependency link.</p> myproject.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\n# Get the current directory\nROOT = Path(__file__).parent\n# Define targets\nadd = Target('add', type=Type.STATIC_LIBRARY)\\\n    .add_sources(Scope.PRIVATE, ROOT / 'src/add.cpp')\\\n    .add_includes(Scope.PUBLIC, ROOT / 'include')\n\nmain = Target('main')\\\n    .depend_on(add)\n\nif __name__ == '__main__':\n    # Create a builder and compile the targets\n    builder = Builder()\n    builder.attach(main)\n    builder.build()\n</code></pre> <p>Note the <code>type</code> parameter in the <code>Target</code> constructor. By default, it produces an executable, but here we specify <code>STATIC_LIBRARY</code> to build a static library.</p> <p>The <code>Scope</code> parameter defines the visibility of metadata:</p> <ul> <li><code>Scope.PUBLIC</code>: Visible to the current target and all targets that depend on it.</li> <li><code>Scope.PRIVATE</code>: Visible only to the current target.</li> <li><code>Scope.INTERFACE</code>: Visible only to dependent targets, not to the current target.</li> </ul> <p>In the example above, we pass the include path with <code>Scope.PUBLIC</code>, so dependent targets like <code>main</code> automatically receive it. Because <code>main</code> depends on <code>add</code>, the builder will compile <code>add</code> first, then <code>main</code>.</p>"},{"location":"quick/#building-across-multiple-projects","title":"Building Across Multiple Projects","text":"<p>To reuse external projects without reinventing the wheel, buildcpp supports multi-project builds. Imagine two projects:</p> <pre><code>myproject/\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 myproject.py\n\nthirdparty/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 thirdparty.h\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 thirdparty.cpp\n\u2514\u2500\u2500 thirdparty.py\n</code></pre> <p>The third-party project exposes its target via an <code>export</code> variable:</p> thirdparty.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\n# Get the current directory\nROOT = Path(__file__).parent\n# Define target\nthirdparty = Target('thirdparty', type=Type.STATIC_LIBRARY)\\\n    .add_sources(Scope.PRIVATE, ROOT / 'src/thirdparty.cpp')\\\n    .add_includes(Scope.PUBLIC, ROOT / 'include')\n\nexport = [thirdparty]\n# Alternatively:\n# export = thirdparty\n\nif __name__ == '__main__':\n    builder = Builder()\n    builder.attach(thirdparty)\n    builder.build()\n</code></pre> <p>The <code>export</code> variable is a convention in buildcpp for exposing targets to other projects.</p> <p>Your own project can then import and use that target:</p> myproject.py<pre><code>from buildcpp import Target, Builder, Scope\nfrom pathlib import Path\n\nthirdparty = import_project('path/to/thirdparty')['thirdparty']\n\n# Get the current directory\nROOT = Path(__file__).parent\n# Define target\nmain = Target('main')\\\n    .add_sources(Scope.PRIVATE, ROOT / 'main.cpp')\\\n    .depend_on(thirdparty)\n\nif __name__ == '__main__':\n    builder = Builder()\n    builder.attach(main)\n    builder.build()\n</code></pre> <p>The <code>import_project</code> function returns a dictionary (similar to a C++ <code>hashmap</code>) where keys are target names and values are <code>Target</code> instances. These can be used just like locally defined targets.</p>"}]}